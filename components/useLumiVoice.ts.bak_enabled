"use client";

import { useEffect, useMemo, useState } from "react";
import { getLumiEnabled } from "@/lib/lumiSettings";

export type VoiceStatus = "idle" | "speaking" | "paused";

function chunkText(text: string) {
  const cleaned = text.replace(/\s+/g, " ").trim();
  if (!cleaned) return [];
  return cleaned.split(/(?<=[.!?])\s+/);
}

export default function useLumiVoice() {
  const [status, setStatus] = useState<VoiceStatus>("idle");
  const [voices, setVoices] = useState<SpeechSynthesisVoice[]>([]);

  useEffect(() => {
    if (typeof window === "undefined" || !("speechSynthesis" in window)) return;

    function load() {
      setVoices(window.speechSynthesis.getVoices());
    }

    load();
    window.speechSynthesis.onvoiceschanged = load;

    return () => {
      window.speechSynthesis.onvoiceschanged = null;
    };
  }, []);

  const bestVoice = useMemo(() => {
    if (!voices.length) return null;

    const preferred = ["Samantha", "Ava", "Victoria", "Allison", "Google US English"];
    const avoid = /robot|zira|fred|male|compact/i;

    const candidates = voices
      .filter((v) => v.lang?.startsWith("en"))
      .filter((v) => !avoid.test(v.name))
      .sort((a, b) => Number(b.localService) - Number(a.localService));

    for (const name of preferred) {
      const found = candidates.find((v) => v.name === name);
      if (found) return found;
    }

    return candidates[0] || voices[0];
  }, [voices]);

  function stop() {
    if (typeof window === "undefined" || !("speechSynthesis" in window)) return;
    window.speechSynthesis.cancel();
    setStatus("idle");
  }

  function speak(text: string) {
    if (!getLumiEnabled()) return;
    if (typeof window === "undefined" || !("speechSynthesis" in window)) return;
    if (!text?.trim()) return;

    stop();
    setStatus("speaking");

    const parts = chunkText(text);
    parts.forEach((p, idx) => {
      const u = new SpeechSynthesisUtterance(p);
      if (bestVoice) u.voice = bestVoice;

      // decent baseline for beta
      u.rate = 0.92;
      u.pitch = 1.05;
      u.volume = 1;

      u.onend = () => {
        if (idx === parts.length - 1) setStatus("idle");
      };
      u.onerror = () => setStatus("idle");

      window.speechSynthesis.speak(u);
    });
  }

  function pause() {
    if (typeof window === "undefined" || !("speechSynthesis" in window)) return;
    window.speechSynthesis.pause();
    setStatus("paused");
  }

  function resume() {
    if (typeof window === "undefined" || !("speechSynthesis" in window)) return;
    window.speechSynthesis.resume();
    setStatus("speaking");
  }

  return {
    supported: typeof window !== "undefined" && "speechSynthesis" in window,
    status,
    isSpeaking: status === "speaking",
    speak,
    stop,
    pause,
    resume,
    voiceName: bestVoice?.name ?? null,
  };
}
